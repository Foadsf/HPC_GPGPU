/**
 * 004_Heterogeneous_MatrixMul
 * 
 * Demonstrates matrix operations using both:
 *   - ARM NEON assembly (4×4 matrix multiply)
 *   - VideoCore IV QPU assembly (16-element vector operations)
 *
 * This MWE shows the principles of heterogeneous computing where
 * different processors handle different parts of the computation.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <unistd.h>

// QPU kernel binary (generated by vc4asm)
static const uint32_t qpu_kernel[] = {
#include "qpu_matmul.hex"
};

// =============================================================================
// Hardware Constants
// =============================================================================
#define BCM2709_PERI_BASE   0x3F000000
#define MAJOR_NUM           100
#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
#define DEVICE_FILE_NAME    "/dev/vcio"

#define MEM_FLAG_DIRECT     (1 << 2)
#define MEM_FLAG_COHERENT   (2 << 2)
#define MEM_FLAG_ZERO       (1 << 4)
#define BUS_TO_PHYS(x)      ((x) & ~0xC0000000)

// =============================================================================
// External ARM Assembly Functions
// =============================================================================
extern void cpu_matmul_4x4_neon(const float *A, const float *B, float *C);

// =============================================================================
// Mailbox Interface
// =============================================================================
static int mbox_fd = -1;

static int mbox_property(int file_desc, void *buf) {
    return ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
}

static int mbox_open(void) {
    int fd = open(DEVICE_FILE_NAME, 0);
    if (fd < 0) {
        perror("Cannot open /dev/vcio");
    }
    return fd;
}

static void mbox_close(int fd) {
    close(fd);
}

static unsigned mem_alloc(int fd, unsigned size, unsigned align, unsigned flags) {
    unsigned p[32] = {0};
    int i = 0;
    p[i++] = 0;           // size
    p[i++] = 0x00000000;  // request
    p[i++] = 0x3000c;     // tag: allocate
    p[i++] = 12;
    p[i++] = 12;
    p[i++] = size;
    p[i++] = align;
    p[i++] = flags;
    p[i++] = 0x00000000;  // end tag
    p[0] = i * sizeof(unsigned);
    
    if (mbox_property(fd, p) < 0) return 0;
    return p[5];
}

static unsigned mem_lock(int fd, unsigned handle) {
    unsigned p[32] = {0};
    int i = 0;
    p[i++] = 0;
    p[i++] = 0x00000000;
    p[i++] = 0x3000d;     // tag: lock
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = handle;
    p[i++] = 0x00000000;
    p[0] = i * sizeof(unsigned);
    
    if (mbox_property(fd, p) < 0) return 0;
    return p[5];
}

static unsigned mem_unlock(int fd, unsigned handle) {
    unsigned p[32] = {0};
    int i = 0;
    p[i++] = 0;
    p[i++] = 0x00000000;
    p[i++] = 0x3000e;     // tag: unlock
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = handle;
    p[i++] = 0x00000000;
    p[0] = i * sizeof(unsigned);
    
    if (mbox_property(fd, p) < 0) return 0;
    return p[5];
}

static unsigned mem_free(int fd, unsigned handle) {
    unsigned p[32] = {0};
    int i = 0;
    p[i++] = 0;
    p[i++] = 0x00000000;
    p[i++] = 0x3000f;     // tag: free
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = handle;
    p[i++] = 0x00000000;
    p[0] = i * sizeof(unsigned);
    
    if (mbox_property(fd, p) < 0) return 0;
    return p[5];
}

static unsigned qpu_enable(int fd, unsigned enable) {
    unsigned p[32] = {0};
    int i = 0;
    p[i++] = 0;
    p[i++] = 0x00000000;
    p[i++] = 0x30012;     // tag: enable QPU
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = enable;
    p[i++] = 0x00000000;
    p[0] = i * sizeof(unsigned);
    
    if (mbox_property(fd, p) < 0) return 0;
    return p[5];
}

static unsigned execute_qpu(int fd, unsigned num_qpus, unsigned control,
                            unsigned noflush, unsigned timeout) {
    unsigned p[32] = {0};
    int i = 0;
    p[i++] = 0;
    p[i++] = 0x00000000;
    p[i++] = 0x30011;     // tag: execute QPU
    p[i++] = 16;
    p[i++] = 16;
    p[i++] = num_qpus;
    p[i++] = control;
    p[i++] = noflush;
    p[i++] = timeout;
    p[i++] = 0x00000000;
    p[0] = i * sizeof(unsigned);
    
    if (mbox_property(fd, p) < 0) return 0;
    return p[5];
}

static void *mapmem(unsigned base, unsigned size) {
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (fd < 0) {
        perror("Cannot open /dev/mem");
        return NULL;
    }
    
    unsigned offset = base % getpagesize();
    base -= offset;
    size += offset;
    
    void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, base);
    close(fd);
    
    if (mem == MAP_FAILED) return NULL;
    return (char *)mem + offset;
}

static void unmapmem(void *addr, unsigned size) {
    unsigned offset = (unsigned)(uintptr_t)addr % getpagesize();
    munmap((char *)addr - offset, size + offset);
}

// =============================================================================
// Timing Utility
// =============================================================================
static double get_time_us(void) {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec * 1e6 + tv.tv_usec;
}

// =============================================================================
// Reference CPU Implementation
// =============================================================================
static void cpu_matmul_4x4_reference(const float *A, const float *B, float *C) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            float sum = 0.0f;
            for (int k = 0; k < 4; k++) {
                sum += A[i * 4 + k] * B[k * 4 + j];
            }
            C[i * 4 + j] = sum;
        }
    }
}

static void cpu_vector_mul_reference(const float *A, const float *B, float *C, int n) {
    for (int i = 0; i < n; i++) {
        C[i] = A[i] * B[i];
    }
}

// =============================================================================
// Main Program
// =============================================================================
int main(void) {
    printf("=== 004_Heterogeneous_MatrixMul ===\n\n");
    
    // =========================================================================
    // Part 1: ARM NEON 4×4 Matrix Multiplication
    // =========================================================================
    printf("[CPU] ARM NEON 4x4 Matrix Multiply\n");
    
    // Initialize test matrices
    float A_4x4[16] = {
        1, 2, 3, 4,
        5, 6, 7, 8,
        9, 10, 11, 12,
        13, 14, 15, 16
    };
    
    float B_4x4[16] = {
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
    };  // Identity matrix - result should equal A
    
    float C_neon[16] = {0};
    float C_ref[16] = {0};
    
    // Compute with NEON assembly
    double t0 = get_time_us();
    cpu_matmul_4x4_neon(A_4x4, B_4x4, C_neon);
    double t1 = get_time_us();
    double neon_time = t1 - t0;
    
    // Compute reference
    cpu_matmul_4x4_reference(A_4x4, B_4x4, C_ref);
    
    // Verify
    int neon_pass = 1;
    float max_err = 0;
    for (int i = 0; i < 16; i++) {
        float err = fabsf(C_neon[i] - C_ref[i]);
        if (err > max_err) max_err = err;
        if (err > 0.001f) neon_pass = 0;
    }
    
    printf("      Input A (row 0): [%.1f, %.1f, %.1f, %.1f]\n", 
           A_4x4[0], A_4x4[1], A_4x4[2], A_4x4[3]);
    printf("      Result C (row 0): [%.1f, %.1f, %.1f, %.1f]\n",
           C_neon[0], C_neon[1], C_neon[2], C_neon[3]);
    printf("      Time: %.2f µs\n", neon_time);
    printf("      Max error: %.6f\n", max_err);
    printf("      %s\n\n", neon_pass ? "[PASS] NEON assembly verified" : "[FAIL]");
    
    // Now test with non-identity B
    float B_test[16] = {
        1, 2, 3, 4,
        5, 6, 7, 8,
        9, 10, 11, 12,
        13, 14, 15, 16
    };
    
    cpu_matmul_4x4_neon(A_4x4, B_test, C_neon);
    cpu_matmul_4x4_reference(A_4x4, B_test, C_ref);
    
    printf("      Non-trivial test: A × B where A=B=[1..16]\n");
    printf("      NEON C[0][0] = %.1f (expected: %.1f)\n", C_neon[0], C_ref[0]);
    printf("      NEON C[3][3] = %.1f (expected: %.1f)\n", C_neon[15], C_ref[15]);
    
    // =========================================================================
    // Part 2: VideoCore IV QPU Vector Operations
    // =========================================================================
    printf("\n[GPU] VideoCore IV QPU 16-Element Vector Multiply\n");
    
    mbox_fd = mbox_open();
    if (mbox_fd < 0) {
        printf("      [SKIP] Cannot open mailbox - GPU test skipped\n");
        return 0;
    }
    
    qpu_enable(mbox_fd, 1);
    
    // Allocate GPU memory
    unsigned mem_size = 64 * 1024;  // 64KB
    unsigned handle = mem_alloc(mbox_fd, mem_size, 4096, 
                                MEM_FLAG_DIRECT | MEM_FLAG_ZERO);
    if (!handle) {
        printf("      [FAIL] GPU memory allocation failed\n");
        mbox_close(mbox_fd);
        return 1;
    }
    
    unsigned bus_addr = mem_lock(mbox_fd, handle);
    unsigned phys_addr = BUS_TO_PHYS(bus_addr);
    
    volatile uint32_t *gpu_mem = (volatile uint32_t *)mapmem(phys_addr, mem_size);
    if (!gpu_mem) {
        printf("      [FAIL] Cannot map GPU memory\n");
        mem_unlock(mbox_fd, handle);
        mem_free(mbox_fd, handle);
        mbox_close(mbox_fd);
        return 1;
    }
    
    printf("      GPU memory allocated at bus addr: 0x%08X\n", bus_addr);
    
    // Memory layout:
    //   0x0000: QPU code
    //   0x1000: Uniforms
    //   0x2000: Vector A (16 floats)
    //   0x2100: Vector B (16 floats)
    //   0x2200: Vector C output (16 floats)
    //   0x3000: Control list
    
    unsigned code_offset = 0x0000;
    unsigned unif_offset = 0x1000;
    unsigned vec_a_offset = 0x2000;
    unsigned vec_b_offset = 0x2100;
    unsigned vec_c_offset = 0x2200;
    unsigned ctrl_offset = 0x3000;
    
    // Copy QPU kernel
    memcpy((void *)gpu_mem, qpu_kernel, sizeof(qpu_kernel));
    printf("      Copied QPU kernel (%zu bytes)\n", sizeof(qpu_kernel));
    
    // Initialize vectors
    volatile float *vec_a = (volatile float *)((char *)gpu_mem + vec_a_offset);
    volatile float *vec_b = (volatile float *)((char *)gpu_mem + vec_b_offset);
    volatile float *vec_c = (volatile float *)((char *)gpu_mem + vec_c_offset);
    
    for (int i = 0; i < 16; i++) {
        vec_a[i] = (float)(i + 1);        // A = [1, 2, 3, ..., 16]
        vec_b[i] = (float)(i + 1);        // B = [1, 2, 3, ..., 16]
        vec_c[i] = 0.0f;                   // C = result (A * B element-wise)
    }
    
    printf("      Vector A: [1, 2, 3, ..., 16]\n");
    printf("      Vector B: [1, 2, 3, ..., 16]\n");
    printf("      Expected C: [1, 4, 9, ..., 256]\n");
    
    // Set up uniforms (parameters for QPU)
    volatile uint32_t *uniforms = (volatile uint32_t *)((char *)gpu_mem + unif_offset);
    uniforms[0] = bus_addr + vec_a_offset;   // Address of A
    uniforms[1] = bus_addr + vec_b_offset;   // Address of B
    uniforms[2] = bus_addr + vec_c_offset;   // Address of C
    uniforms[3] = 16;                         // Number of elements
    
    // Set up control list (uniforms addr, code addr)
    volatile uint32_t *ctrl = (volatile uint32_t *)((char *)gpu_mem + ctrl_offset);
    ctrl[0] = bus_addr + unif_offset;    // Uniforms address
    ctrl[1] = bus_addr + code_offset;    // Code address
    
    // Execute QPU
    printf("      Executing QPU kernel...\n");
    t0 = get_time_us();
    unsigned result = execute_qpu(mbox_fd, 1, bus_addr + ctrl_offset, 0, 10000);
    t1 = get_time_us();
    double qpu_time = t1 - t0;
    
    printf("      execute_qpu returned: 0x%08X\n", result);
    printf("      Time: %.2f µs\n", qpu_time);
    
    // Small delay
    usleep(1000);
    
    // Verify results
    printf("      Reading results...\n");
    
    float ref_c[16];
    float host_a[16], host_b[16];
    for (int i = 0; i < 16; i++) {
        host_a[i] = (float)(i + 1);
        host_b[i] = (float)(i + 1);
    }
    cpu_vector_mul_reference(host_a, host_b, ref_c, 16);
    
    int qpu_pass = 1;
    max_err = 0;
    for (int i = 0; i < 16; i++) {
        float err = fabsf(vec_c[i] - ref_c[i]);
        if (err > max_err) max_err = err;
        if (err > 0.001f) qpu_pass = 0;
    }
    
    printf("      C[0]  = %.1f (expected: %.1f)\n", vec_c[0], ref_c[0]);
    printf("      C[15] = %.1f (expected: %.1f)\n", vec_c[15], ref_c[15]);
    printf("      Max error: %.6f\n", max_err);
    
    if (qpu_pass) {
        printf("      [PASS] QPU assembly verified\n");
    } else if (vec_c[0] == 0.0f) {
        printf("      [INFO] QPU did not write results (driver issue?)\n");
    } else {
        printf("      [FAIL] Results don't match\n");
    }
    
    // =========================================================================
    // Summary
    // =========================================================================
    printf("\n=== Performance Summary ===\n");
    printf("      CPU (NEON 4×4 matmul): %.2f µs\n", neon_time);
    printf("      GPU (QPU 16-vec mul):  %.2f µs\n", qpu_time);
    printf("\n");
    
    // Cleanup
    unmapmem((void *)gpu_mem, mem_size);
    mem_unlock(mbox_fd, handle);
    mem_free(mbox_fd, handle);
    qpu_enable(mbox_fd, 0);
    mbox_close(mbox_fd);
    
    printf("[DONE]\n");
    return 0;
}

// main.c
// 003_Heterogeneous_Assembly - Minimal Working Example
// Demonstrates running assembly on both CPU (ARMv7) and GPU (VideoCore IV QPU)

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <string.h>

// Include the binary QPU kernel (generated by vc4asm -C)
// vc4asm -C outputs raw hex only, so we wrap it ourselves
static const uint32_t qpu_kernel[] = {
#include "qpu_kernel.hex"
};

// ----------------------------------------------------------------------------
// HARDWARE CONSTANTS (Raspberry Pi 2/3)
// ----------------------------------------------------------------------------
// For Pi 2/3, peripheral base is 0x3F000000
// For Pi 1, it would be 0x20000000
// For Pi 4, it would be 0xFE000000
#define BCM2709_PERI_BASE   0x3F000000
#define V3D_BASE            (BCM2709_PERI_BASE + 0xC00000)

// Mailbox Constants (from official Raspberry Pi userland)
#define MAJOR_NUM           100
#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
#define DEVICE_FILE_NAME    "/dev/vcio"

// Memory flags for GPU allocation
#define MEM_FLAG_DISCARDABLE      (1 << 0)
#define MEM_FLAG_NORMAL           (0 << 2)
#define MEM_FLAG_DIRECT           (1 << 2)  // 0xC alias uncached
#define MEM_FLAG_COHERENT         (2 << 2)  // 0x8 alias
#define MEM_FLAG_L1_NONALLOCATING (MEM_FLAG_DIRECT | MEM_FLAG_COHERENT)
#define MEM_FLAG_ZERO             (1 << 4)
#define MEM_FLAG_NO_INIT          (1 << 5)
#define MEM_FLAG_HINT_PERMALOCK   (1 << 6)

// Bus address to physical address mask (for Pi 2/3)
#define BUS_TO_PHYS(x) ((x) & ~0xC0000000)

// ----------------------------------------------------------------------------
// EXTERNAL ASSEMBLY FUNCTION (ARMv7)
// ----------------------------------------------------------------------------
extern int cpu_add_asm(int a, int b);

// ----------------------------------------------------------------------------
// MAILBOX INTERFACE (Based on official Raspberry Pi userland code)
// ----------------------------------------------------------------------------
static int mbox_fd = -1;

static int mbox_property(int file_desc, void *buf) {
    int ret_val = ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
    if (ret_val < 0) {
        perror("ioctl mbox_property failed");
    }
    return ret_val;
}

int mbox_open(void) {
    int file_desc = open(DEVICE_FILE_NAME, 0);
    if (file_desc < 0) {
        perror("Can't open /dev/vcio");
        printf("Try: sudo mknod /dev/vcio c %d 0\n", MAJOR_NUM);
    }
    return file_desc;
}

void mbox_close(int file_desc) {
    close(file_desc);
}

unsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags) {
    int i = 0;
    unsigned p[32];
    
    p[i++] = 0;           // total size (filled in below)
    p[i++] = 0x00000000;  // process request
    
    p[i++] = 0x3000c;     // tag: allocate memory
    p[i++] = 12;          // buffer size
    p[i++] = 12;          // request size
    p[i++] = size;        // size in bytes
    p[i++] = align;       // alignment
    p[i++] = flags;       // flags
    
    p[i++] = 0x00000000;  // end tag
    p[0] = i * sizeof(*p);  // actual total size
    
    if (mbox_property(file_desc, p) < 0)
        return 0;
    return p[5];  // return handle
}

unsigned mem_free(int file_desc, unsigned handle) {
    int i = 0;
    unsigned p[32];
    
    p[i++] = 0;
    p[i++] = 0x00000000;
    
    p[i++] = 0x3000f;     // tag: release memory
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = handle;
    
    p[i++] = 0x00000000;
    p[0] = i * sizeof(*p);
    
    if (mbox_property(file_desc, p) < 0)
        return 0;
    return p[5];
}

unsigned mem_lock(int file_desc, unsigned handle) {
    int i = 0;
    unsigned p[32];
    
    p[i++] = 0;
    p[i++] = 0x00000000;
    
    p[i++] = 0x3000d;     // tag: lock memory
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = handle;
    
    p[i++] = 0x00000000;
    p[0] = i * sizeof(*p);
    
    if (mbox_property(file_desc, p) < 0)
        return 0;
    return p[5];  // return bus address
}

unsigned mem_unlock(int file_desc, unsigned handle) {
    int i = 0;
    unsigned p[32];
    
    p[i++] = 0;
    p[i++] = 0x00000000;
    
    p[i++] = 0x3000e;     // tag: unlock memory
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = handle;
    
    p[i++] = 0x00000000;
    p[0] = i * sizeof(*p);
    
    if (mbox_property(file_desc, p) < 0)
        return 0;
    return p[5];
}

unsigned qpu_enable(int file_desc, unsigned enable) {
    int i = 0;
    unsigned p[32];
    
    p[i++] = 0;
    p[i++] = 0x00000000;
    
    p[i++] = 0x30012;     // tag: enable QPU
    p[i++] = 4;
    p[i++] = 4;
    p[i++] = enable;
    
    p[i++] = 0x00000000;
    p[0] = i * sizeof(*p);
    
    if (mbox_property(file_desc, p) < 0)
        return 0;
    return p[5];
}

unsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, 
                     unsigned noflush, unsigned timeout) {
    int i = 0;
    unsigned p[32];
    
    p[i++] = 0;
    p[i++] = 0x00000000;
    
    p[i++] = 0x30011;     // tag: execute QPU
    p[i++] = 16;
    p[i++] = 16;
    p[i++] = num_qpus;
    p[i++] = control;
    p[i++] = noflush;
    p[i++] = timeout;
    
    p[i++] = 0x00000000;
    p[0] = i * sizeof(*p);
    
    if (mbox_property(file_desc, p) < 0)
        return 0;
    return p[5];
}

// Map physical address to virtual address
void *mapmem(unsigned base, unsigned size) {
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (fd < 0) {
        perror("Can't open /dev/mem. Run with sudo.");
        return NULL;
    }
    
    unsigned offset = base % getpagesize();
    base = base - offset;
    size = size + offset;
    
    void *mem = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, base);
    close(fd);
    
    if (mem == MAP_FAILED) {
        perror("mmap failed");
        return NULL;
    }
    return (char *)mem + offset;
}

void unmapmem(void *addr, unsigned size) {
    unsigned offset = (unsigned)addr % getpagesize();
    addr = (char *)addr - offset;
    size = size + offset;
    munmap(addr, size);
}

// ----------------------------------------------------------------------------
// MAIN
// ----------------------------------------------------------------------------
int main() {
    printf("--- 003_Heterogeneous_Assembly ---\n\n");

    // =========================================================================
    // 1. CPU ASSEMBLY TEST
    // =========================================================================
    printf("[CPU] Testing ARMv7 Assembly...\n");
    int sum = cpu_add_asm(10, 20);
    printf("      10 + 20 = %d (Calculated by cpu_ops.s)\n", sum);
    if (sum != 30) {
        fprintf(stderr, "      [FAIL] CPU ASM returned wrong value!\n");
        return 1;
    }
    printf("      [PASS]\n\n");

    // =========================================================================
    // 2. GPU ASSEMBLY SETUP
    // =========================================================================
    printf("[GPU] Preparing VideoCore IV QPU...\n");

    // Open mailbox
    mbox_fd = mbox_open();
    if (mbox_fd < 0) {
        return 1;
    }
    printf("      Mailbox opened successfully.\n");

    // Enable QPU
    if (qpu_enable(mbox_fd, 1) == 0) {
        fprintf(stderr, "      [WARN] QPU enable returned 0 (may already be enabled)\n");
    } else {
        printf("      QPU enabled.\n");
    }

    // Allocate GPU memory (4KB should be plenty)
    // Use MEM_FLAG_DIRECT for uncached access
    unsigned mem_size = 4096;
    unsigned handle = mem_alloc(mbox_fd, mem_size, 4096, MEM_FLAG_DIRECT | MEM_FLAG_ZERO);
    if (!handle) {
        fprintf(stderr, "      [FAIL] GPU memory allocation failed!\n");
        fprintf(stderr, "      Possible causes:\n");
        fprintf(stderr, "        - Not enough GPU memory (check gpu_mem in /boot/config.txt)\n");
        fprintf(stderr, "        - vc4 driver loaded (check /boot/config.txt for dtoverlay=vc4-fkms-v3d)\n");
        mbox_close(mbox_fd);
        return 1;
    }
    printf("      Allocated GPU memory, handle: 0x%08X\n", handle);

    // Lock memory to get bus address
    unsigned bus_addr = mem_lock(mbox_fd, handle);
    if (!bus_addr) {
        fprintf(stderr, "      [FAIL] GPU memory lock failed!\n");
        mem_free(mbox_fd, handle);
        mbox_close(mbox_fd);
        return 1;
    }
    printf("      Locked memory at bus address: 0x%08X\n", bus_addr);

    // Convert bus address to physical address for mmap
    unsigned phys_addr = BUS_TO_PHYS(bus_addr);
    printf("      Physical address: 0x%08X\n", phys_addr);

    // Map GPU memory to user space
    volatile uint32_t *gpu_mem = (volatile uint32_t *)mapmem(phys_addr, mem_size);
    if (!gpu_mem) {
        fprintf(stderr, "      [FAIL] Failed to map GPU memory!\n");
        mem_unlock(mbox_fd, handle);
        mem_free(mbox_fd, handle);
        mbox_close(mbox_fd);
        return 1;
    }
    printf("      Mapped GPU memory to user space.\n");

    // =========================================================================
    // Memory Layout:
    //   Offset 0:     QPU Code
    //   Offset 256:   Uniforms (16 uint32_t entries for control list)
    //   Offset 512:   Output Data
    // =========================================================================
    
    // Copy QPU kernel code to GPU memory
    printf("      Copying QPU kernel (%zu bytes)...\n", sizeof(qpu_kernel));
    memcpy((void *)gpu_mem, qpu_kernel, sizeof(qpu_kernel));

    // Setup uniforms (parameters for QPU)
    // Uniform 0: Bus address where QPU should write the result
    unsigned output_bus_addr = bus_addr + 512;
    gpu_mem[64] = output_bus_addr;  // Offset 256 bytes = index 64
    
    // Initialize output to known value (so we can verify it changed)
    gpu_mem[128] = 0xDEADBEEF;  // Offset 512 bytes = index 128

    printf("      Uniforms set. Output address: 0x%08X\n", output_bus_addr);
    printf("      Initial output value: 0x%08X\n", gpu_mem[128]);

    // =========================================================================
    // 3. EXECUTE QPU KERNEL
    // =========================================================================
    printf("\n[GPU] Launching QPU Kernel...\n");

    // Setup control list for execute_qpu
    // The control list is an array of (uniforms_addr, code_addr) pairs
    // We put it at offset 768 (index 192)
    unsigned control_bus_addr = bus_addr + 768;
    gpu_mem[192] = bus_addr + 256;  // Uniforms address
    gpu_mem[193] = bus_addr;        // Code address

    // Execute on 1 QPU
    unsigned result = execute_qpu(mbox_fd, 1, control_bus_addr, 0, 10000);
    printf("      execute_qpu returned: 0x%08X\n", result);

    // Small delay to ensure QPU finishes
    usleep(1000);

    // =========================================================================
    // 4. VERIFY RESULTS
    // =========================================================================
    printf("\n[GPU] Verifying Results...\n");
    uint32_t output = gpu_mem[128];
    printf("      Read back value: 0x%08X\n", output);

    if (output == 0x1337) {
        printf("      [SUCCESS] QPU wrote the magic number!\n");
    } else if (output == 0xDEADBEEF) {
        printf("      [INFO] Output unchanged - QPU may not have executed.\n");
        printf("      This could be due to:\n");
        printf("        - vc4 graphics driver blocking QPU access\n");
        printf("        - V3D hardware not available\n");
        printf("        - Kernel/firmware limitations\n");
    } else {
        printf("      [PARTIAL] Output changed but not to expected value.\n");
    }

    // =========================================================================
    // 5. CLEANUP
    // =========================================================================
    printf("\n[CLEANUP] Releasing resources...\n");
    unmapmem((void *)gpu_mem, mem_size);
    mem_unlock(mbox_fd, handle);
    mem_free(mbox_fd, handle);
    qpu_enable(mbox_fd, 0);
    mbox_close(mbox_fd);
    printf("      Done.\n");

    return 0;
}
